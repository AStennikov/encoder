/*
 * hall_sensor.c
 *
 *  Created on: Jan 23, 2021
 *      Author: asten
 */


#include "hall_sensor.h"
#include "stm32g4xx_hal_conf.h"
#include "adc.h"

// A139x sensors have a sleep mode with power-on time of 60us max and power off-time of 1us. These constants allow fine tuning delays between GPIO action
#define T_PON	1000
#define T_POFF	50

// sensors are not located in a nice incremental order, so the readings are rearranged with the help of a look-up table
const uint32_t sensorOrderLUT[SENSOR_COUNT] = {0,1,2,3,7,6,5,4,8,9,10,11,15,14,13,12,16,17,18,19};

// sensors' offset voltages, obtained with sensorArrayOffset.py
const int16_t sensorOffsets[SENSOR_COUNT] = {1955, 1945, 1934, 1946, 1945, 1938, 1923, 1914, 1958, 1925, 1958, 1921,
		 1954, 1938, 1956, 1961, 1916, 1958, 1935, 1975};

// magnetic pattern, generated by wavelet.py
const int32_t magneticPattern[MAGNETIC_PATTERN_LENGTH] = {-2200, -1500, -900, -550, -270, 0, 25, 50, 75, 75, 100, 75, 100, 75, 100, 75, 75, 50, 25, 0, -270, -550, -900, -1500, -2200, -1500, -900, -550, -270, 0, 25, 50, 75, 75, 75, 50, 50, 25, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 25, 50, 50, 75, 75, 75, 50, 25, 0, -270, -550, -900, -1500, -2200, -1500, -900, -550, -270, 0, 25, 50, 75, 75, 100, 75, 100, 75, 100, 75, 75, 50, 25, 0, -270, -550, -900, -1500, -2200, -1500, -900, -550, -270, 0, 25, 50, 75, 75, 50, 25, 0, -25, -50, -75, -75, -50, -25, 0, 270, 550, 900, 1500, 2200, 1500, 900, 550, 270, 0, -25, -50, -75, -75, -50, -25, 0, 25, 50, 75, 75, 50, 25, 0, -270, -550, -900, -1500, -2200, -1500, -900, -550, -270, 0, 25, 50, 75, 75, 75, 50, 50, 25, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 25, 50, 50, 75, 75, 75, 50, 25, 0, -270, -550, -900, -1500, -2200, -1500, -900, -550, -270, 0, 25, 50, 75, 75, 75, 50, 50, 25, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -25, -25, -50, -50, -75, -75, -75, -50, -25, 0, 270, 550, 900, 1500, 2200, 1500, 900, 550, 270, 0, -25, -50, -75, -75, -50, -25, 0, 25, 50, 75, 75, 50, 25, 0, -270, -550, -900, -1500, -2200, -1500, -900, -550, -270, 0, 25, 50, 75, 75, 50, 25, 0, -25, -50, -75, -75, -50, -25, 0, 270, 550, 900, 1500, 2200, 1500, 900, 550, 270, 0, -25, -50, -75, -75, -75, -50, -50, -25, -25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 25, 50, 50, 75, 75, 75, 50, 25, 0, -270, -550, -900, -1500, -2200, -1500, -900, -550, -270, 0, 25, 50, 75, 75, 50, 25, 0, -25, -50, -75, -75, -50, -25, 0, 270, 550, 900, 1500, 2200, 1500, 900, 550, 270, 0, -25, -50, -75, -75, -100, -75, -100, -75, -100, -75, -75, -50, -25, 0, 270, 550, 900, 1500, 2200, 1500, 900, 550, 270, 0, -25, -50, -75, -75, -75, -50, -50, -25, -25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -25, -25, -50, -50, -75, -75, -75, -50, -25, 0, 270, 550, 900, 1500, 2200, 1500, 900, 550, 270, 0, -25, -50, -75, -75, -75, -50, -50, -25, -25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -25, -25, -50, -50, -75, -75, -75, -50, -25, 0, 270, 550, 900, 1500, 2200, 1500, 900, 550, 270, 0, -25, -50, -75, -75, -100, -75, -100, -75, -100, -75, -75, -50, -25, 0, 270, 550, 900, 1500, 2200, 1500, 900, 550, 270, 0, -25, -50, -75, -75, -50, -25, 0, 25, 50, 75, 75, 50, 25, 0, -270, -550, -900, -1500};



void removeOffsets(int16_t* values) {
	for (uint16_t i=0; i<SENSOR_COUNT; ++i) {
			values[i]-= sensorOffsets[i];
	}
}

// activates a certain sensor group
void activateSensorGroup(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin){
	// sets all pins low
	HAL_GPIO_WritePin(GROUP1_GPIO_Port, GROUP1_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GROUP2_GPIO_Port, GROUP2_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GROUP3_GPIO_Port, GROUP3_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GROUP4_GPIO_Port, GROUP4_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GROUP5_GPIO_Port, GROUP5_Pin, GPIO_PIN_RESET);

	// power-off delay
	for (volatile uint32_t i=0; i<T_POFF; ++i){}

	// sets one specific group high
	HAL_GPIO_WritePin(GPIOx, GPIO_Pin, GPIO_PIN_SET);

	// power-on delay
	for (volatile uint32_t i=0; i<T_PON; ++i){}
}

// reads hall sensor values
void getSensorValues(int16_t* values){
	int16_t buffer[SENSOR_COUNT];

	activateSensorGroup(GROUP1_GPIO_Port, GROUP1_Pin);	// enable group 1
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[0]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	activateSensorGroup(GROUP2_GPIO_Port, GROUP2_Pin);	// enable group 2
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[4]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	activateSensorGroup(GROUP3_GPIO_Port, GROUP3_Pin);	// enable group 3
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[8]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	activateSensorGroup(GROUP4_GPIO_Port, GROUP4_Pin);	// enable group 4
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[12]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	activateSensorGroup(GROUP5_GPIO_Port, GROUP5_Pin);	// enable group 5
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[16]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	// rearranging the values according to the look-up table
	for (uint16_t i=0; i<SENSOR_COUNT; ++i) {
		values[i] = buffer[sensorOrderLUT[i]];
	}
}

// applies offset to the sensor values to make average zero
void offsetSensorValues(int16_t* values){
	for (uint16_t i=0; i<SENSOR_COUNT; ++i) {
		values[i] -= sensorOffsets[i];
	}
}

// interpolates sensor values
void interpolateSensorValues(int16_t* originalValues, int32_t* interpolatedValues) {
	// fill array with original values
	for(int i=0; i<SENSOR_COUNT; ++i) {
		interpolatedValues[i*4] = (int32_t) originalValues[i];
	}

	// fill gaps between original values with their averages
	for(int i=2; i<INTERPOLATED_SENSOR_ARRAY_LENGTH; i+=4) {
		interpolatedValues[i-1] 	= (interpolatedValues[i-2] + interpolatedValues[i-2] + interpolatedValues[i-2] + interpolatedValues[i+2])/4;
		interpolatedValues[i] 		= (interpolatedValues[i-2] + interpolatedValues[i-2] + interpolatedValues[i+2] + interpolatedValues[i+2])/4;
		interpolatedValues[i+1] 	= (interpolatedValues[i-2] + interpolatedValues[i+2] + interpolatedValues[i+2] + interpolatedValues[i+2])/4;
	}
}

// finds sensor position
int32_t diff[MAGNETIC_PATTERN_LENGTH];	// difference between magnetic pattern and sensor readings is stored here
uint16_t calculateSensorPosition(int32_t* interpolatedValues) {
	int32_t minimum = 0x7FFFFFFF;
	uint16_t minimumPos = 0;

	for(uint32_t diffPos=0; diffPos<MAGNETIC_PATTERN_LENGTH; ++diffPos) {			// iterating through angles in magnetic pattern
		diff[diffPos] = 0;	// setting previous value to 0

		for(uint32_t valTau=0; valTau<INTERPOLATED_SENSOR_ARRAY_LENGTH; ++valTau){	// adding up difference between magnetic pattern and interpolated values
			int32_t difference = magneticPattern[(diffPos + valTau) % MAGNETIC_PATTERN_LENGTH] - interpolatedValues[valTau];
			diff[diffPos] += difference*difference;
		}

		if (diff[diffPos] < minimum) {
			minimum = diff[diffPos];
			minimumPos = (uint16_t) diffPos;
		}
	}

	return minimumPos;
}



/*// reads ADC values and stores them into the provided array
void updateHallSensorValues(int16_t* values){
	int16_t buffer[SENSOR_COUNT];

	activateSensorGroup(GROUP1_GPIO_Port, GROUP1_Pin, 1000);	// enable group 1
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[0]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	activateSensorGroup(GROUP2_GPIO_Port, GROUP2_Pin, 1000);	// enable group 2
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[4]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	activateSensorGroup(GROUP3_GPIO_Port, GROUP3_Pin, 1000);	// enable group 3
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[8]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	activateSensorGroup(GROUP4_GPIO_Port, GROUP4_Pin, 1000);	// enable group 4
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[12]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	activateSensorGroup(GROUP5_GPIO_Port, GROUP5_Pin, 1000);	// enable group 5
	HAL_ADC_Start_DMA(&hadc2, (uint32_t* ) &(buffer[16]), 4);
	HAL_ADC_PollForConversion(&hadc2, 5);
	HAL_ADC_Stop_DMA(&hadc2);

	// rearranging the values according to the look-up table
	for (uint16_t i=0; i<SENSOR_COUNT; ++i) {
		values[i] = buffer[sensorOrderLUT[i]];
	}

	// removing offsets
	removeOffsets(values);

	// expanding sensor data




	//HAL_ADC_Stop_DMA(ADC_HandleTypeDef *hadc)

	//HAL_ADC_Start(ADC_HandleTypeDef *hadc);
	//HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef *hadc, uint32_t EventType, uint32_t Timeout)
}*/





